{
  "meta": {
    "project": "pedronahum/swift-jupyter",
    "plan_version": "2.0",
    "date": "October 17, 2025",
    "objective": "Modernize swift-jupyter for Jupyter Protocol 5.4, Python 3.10-3.12, and modern Jupyter stack",
    "execution_model": "Region-based phased approach for Claude Code",
    "estimated_total_effort": "16-24 hours",
    "references": {
      "repo": "https://github.com/pedronahum/swift-jupyter",
      "jupyter_messaging": "https://jupyter-client.readthedocs.io/en/stable/messaging.html",
      "jupyter_kernels": "https://jupyter-client.readthedocs.io/en/stable/kernels.html",
      "kernel_test": "https://github.com/jupyter/jupyter_kernel_test"
    }
  },
  "preflight": {
    "description": "Validate environment before starting any work",
    "required_checks": [
      {
        "check": "Python version >= 3.9",
        "command": "python3 --version",
        "expected": "Python 3.9.x or higher"
      },
      {
        "check": "Swift toolchain available",
        "command": "swift --version",
        "expected": "Swift version 5.x"
      },
      {
        "check": "LLDB Python bindings",
        "command": "python3 -c 'import lldb; print(lldb.__file__)'",
        "expected": "Path to lldb.so or lldb.py"
      },
      {
        "check": "Git repository clean",
        "command": "git status --porcelain",
        "expected": "Empty or only untracked files"
      },
      {
        "check": "Can create test branch",
        "command": "git checkout -b modernization-test",
        "expected": "New branch created"
      }
    ],
    "baseline_snapshot": [
      {
        "task": "Document current state",
        "actions": [
          "Run existing tests: pytest test/ -v > baseline_test_results.txt",
          "Try starting kernel: jupyter console --kernel=swift",
          "Record current versions: pip freeze > baseline_requirements.txt",
          "Note any known failures or warnings"
        ]
      }
    ],
    "abort_conditions": [
      "Cannot import lldb from Python",
      "No Swift toolchain found",
      "Python < 3.10"
    ]
  },
  "regions": [
    {
      "region_id": "R1",
      "name": "Foundation & Dependencies",
      "priority": 1,
      "estimated_effort": "2-3 hours",
      "risk": "low",
      "description": "Update dependency specifications, documentation, and ignore files. Low-risk changes that establish the baseline for modern stack.",
      "files": [
        "requirements.txt",
        "README.md",
        ".gitignore",
        ".dockerignore",
        "CONTRIBUTING"
      ],
      "deliverables": [
        "Updated requirements.txt with modern Jupyter stack",
        "README with accurate compatibility matrix",
        "Proper ignore files for Python/Swift artifacts"
      ],
      "rollback_strategy": "Simple git revert; no runtime dependencies"
    },
    {
      "region_id": "R2",
      "name": "Kernel Registration & Specification",
      "priority": 2,
      "estimated_effort": "2-3 hours",
      "risk": "low",
      "description": "Update kernel registration to write modern kernel.json with interrupt_mode and proper metadata.",
      "files": [
        "register.py"
      ],
      "dependencies": [
        "R1"
      ],
      "deliverables": [
        "kernel.json includes interrupt_mode: message",
        "Validation of Swift/LLDB before registration",
        "Environment variables properly set"
      ],
      "rollback_strategy": "Unregister kernel, revert register.py, re-register"
    },
    {
      "region_id": "R3",
      "name": "Core Kernel Protocol",
      "priority": 3,
      "estimated_effort": "4-6 hours",
      "risk": "medium-high",
      "description": "Update swift_kernel.py to implement Jupyter Protocol 5.4, including control channel handlers and modern kernel_info_reply.",
      "files": [
        "swift_kernel.py"
      ],
      "dependencies": [
        "R1",
        "R2"
      ],
      "deliverables": [
        "Protocol version 5.4 compliance",
        "Control channel interrupt_request handler",
        "Control channel shutdown_request handler",
        "Unicode-aware completion",
        "Modern kernel_info_reply structure"
      ],
      "rollback_strategy": "Keep original swift_kernel.py as swift_kernel.py.backup; feature flags for new handlers"
    },
    {
      "region_id": "R4",
      "name": "Display & Communication Layer",
      "priority": 4,
      "estimated_effort": "3-5 hours",
      "risk": "medium",
      "description": "Modernize Swift-side display and communication to delegate message construction to Python Session.",
      "files": [
        "EnableJupyterDisplay.swift",
        "KernelCommunicator.swift",
        "EnableIPythonDisplay.swift"
      ],
      "dependencies": [
        "R3"
      ],
      "deliverables": [
        "Display messages constructed via Python Session",
        "Support for update_display_data with display_id",
        "Thread-safe communication bridge",
        "IPython 8.x compatibility"
      ],
      "rollback_strategy": "Keep old message construction as fallback path behind feature flag"
    },
    {
      "region_id": "R5",
      "name": "LLDB Shell Integration",
      "priority": 5,
      "estimated_effort": "3-4 hours",
      "risk": "medium",
      "description": "Improve LLDB session management, Unicode handling, and interrupt integration.",
      "files": [
        "swift_shell/"
      ],
      "dependencies": [
        "R3"
      ],
      "deliverables": [
        "Robust multiline Swift execution",
        "Unicode-safe code/output handling",
        "Interrupt signal properly handled",
        "Better error messages from LLDB"
      ],
      "rollback_strategy": "Isolated from other regions; can defer if blocking"
    },
    {
      "region_id": "R6",
      "name": "Testing Infrastructure",
      "priority": 6,
      "estimated_effort": "2-3 hours",
      "risk": "low",
      "description": "Modernize test suite with pytest, jupyter_kernel_test, and nbmake.",
      "files": [
        "test/"
      ],
      "dependencies": [
        "R3",
        "R4",
        "R5"
      ],
      "deliverables": [
        "Protocol conformance tests via jupyter_kernel_test",
        "Unit tests for kernel handlers",
        "E2E notebook tests with nbmake",
        "CI configuration for automated testing"
      ],
      "rollback_strategy": "Tests are additive; no rollback needed"
    },
    {
      "region_id": "R7",
      "name": "Containerization",
      "priority": 7,
      "estimated_effort": "2-3 hours",
      "risk": "low",
      "description": "Update Docker images for modern base OS, Python, and Jupyter stack.",
      "files": [
        "docker/Dockerfile",
        "kernel_gateway/Dockerfile"
      ],
      "dependencies": [
        "R1",
        "R2",
        "R3"
      ],
      "deliverables": [
        "Ubuntu 22.04/24.04 or Swift official base image",
        "Python 3.11/3.12 with modern Jupyter",
        "Health checks and proper security settings",
        "Gateway compatible with Jupyter Server 2.x"
      ],
      "rollback_strategy": "Independent from kernel code; can iterate separately"
    }
  ],
  "region_details": {
    "R1_foundation": {
      "region_id": "R1",
      "quick_wins": [
        {
          "task": "Update .gitignore",
          "effort": "5 min",
          "impact": "Clean repo",
          "risk": "none"
        },
        {
          "task": "Update .dockerignore",
          "effort": "5 min",
          "impact": "Smaller images",
          "risk": "none"
        }
      ],
      "tasks": [
        {
          "id": "R1-T1",
          "file": "requirements.txt",
          "description": "Update to modern Jupyter stack",
          "actions": [
            "Replace entire file with modern pinned versions",
            "Add dev dependencies section for testing"
          ],
          "new_content": {
            "core_deps": [
              "jupyter-client>=8.6,<9",
              "ipykernel>=6.29,<7",
              "jupyter-server>=2.0,<3",
              "notebook>=7.0,<8",
              "jupyterlab>=4.0,<5",
              "pyzmq>=25.0",
              "tornado>=6.3",
              "traitlets>=5.9"
            ],
            "dev_deps": [
              "pytest>=7.4",
              "pytest-timeout>=2.1",
              "jupyter_kernel_test>=0.4",
              "nbmake>=1.5",
              "black>=23.0",
              "ruff>=0.1"
            ]
          },
          "validation": [
            "pip install -r requirements.txt (fresh venv)",
            "python -c 'import jupyter_client; print(jupyter_client.__version__)'",
            "jupyter --version"
          ]
        },
        {
          "id": "R1-T2",
          "file": "README.md",
          "description": "Update documentation for modern stack",
          "sections_to_update": [
            {
              "section": "Status",
              "add": "Note unmaintained status but state this plan brings it to modern standards"
            },
            {
              "section": "Requirements",
              "new_content": [
                "Python: 3.10, 3.11, or 3.12",
                "Swift: 5.7+ with LLDB Python 3 bindings",
                "Jupyter: jupyter-client 8.x, JupyterLab 4.x, Notebook 7.x",
                "OS: Ubuntu 22.04+, macOS 12+, or Windows WSL2"
              ]
            },
            {
              "section": "Installation",
              "add_steps": [
                "Verify LLDB Python 3: python3 -c 'import lldb'",
                "Note that interrupt_mode is set to 'message' for better control"
              ]
            },
            {
              "section": "Compatibility Matrix",
              "add_table": true,
              "columns": [
                "Component",
                "Version",
                "Status"
              ],
              "rows": [
                [
                  "Python",
                  "3.10-3.12",
                  "Tested"
                ],
                [
                  "Jupyter Protocol",
                  "5.4",
                  "Compliant"
                ],
                [
                  "JupyterLab",
                  "4.x",
                  "Tested"
                ],
                [
                  "Notebook",
                  "7.x",
                  "Tested"
                ],
                [
                  "Swift",
                  "5.7-5.10",
                  "Compatible"
                ]
              ]
            }
          ],
          "validation": [
            "Render README.md locally and check formatting",
            "Verify all links with link-checker",
            "Follow installation steps in clean environment"
          ]
        },
        {
          "id": "R1-T3",
          "file": ".gitignore",
          "description": "Add modern Python and Swift ignore patterns",
          "add_patterns": [
            "__pycache__/",
            "*.py[cod]",
            "*$py.class",
            ".pytest_cache/",
            ".coverage",
            "htmlcov/",
            "venv/",
            ".venv/",
            "*.egg-info/",
            ".ipynb_checkpoints/",
            ".build/",
            ".swift-build/",
            "*.swiftmodule",
            "baseline_*.txt"
          ]
        },
        {
          "id": "R1-T4",
          "file": ".dockerignore",
          "description": "Optimize Docker build context",
          "add_patterns": [
            "venv/",
            ".venv/",
            "__pycache__/",
            "*.pyc",
            ".pytest_cache/",
            ".git/",
            ".gitignore",
            "*.md",
            "test/",
            ".ipynb_checkpoints/"
          ]
        },
        {
          "id": "R1-T5",
          "file": "CONTRIBUTING",
          "description": "Add or update contribution guidelines",
          "sections": [
            {
              "title": "Development Setup",
              "content": "python3 -m venv venv; source venv/bin/activate; pip install -r requirements.txt; python register.py"
            },
            {
              "title": "Running Tests",
              "content": "pytest test/ -v; python -m jupyter_kernel_test --kernel=swift"
            },
            {
              "title": "Code Style",
              "content": "Python: black + ruff; Swift: swift-format (if available)"
            }
          ]
        }
      ],
      "validation_checkpoint": {
        "must_pass": [
          "pip install succeeds with new requirements.txt",
          "README renders correctly",
          "All documented links are valid"
        ],
        "verification_commands": [
          "python3 -m venv test_venv",
          "source test_venv/bin/activate",
          "pip install -r requirements.txt",
          "python -c 'import jupyter_client, ipykernel, notebook, jupyterlab'",
          "deactivate"
        ]
      }
    },
    "R2_registration": {
      "region_id": "R2",
      "tasks": [
        {
          "id": "R2-T1",
          "file": "register.py",
          "description": "Add LLDB validation before registration",
          "location": "Before kernelspec creation",
          "code_snippet": "def validate_lldb_python3():\n    \"\"\"Validate LLDB can be imported from Python 3.\"\"\"\n    try:\n        import lldb\n        version = lldb.SBDebugger.GetVersionString()\n        print(f\"âœ“ LLDB found: {version}\")\n        print(f\"  LLDB module: {lldb.__file__}\")\n        return True\n    except ImportError as e:\n        print(f\"âœ— Cannot import LLDB from Python: {e}\")\n        print(\"  Ensure Swift toolchain has LLDB Python 3 bindings\")\n        return False\n\nif __name__ == '__main__':\n    if not validate_lldb_python3():\n        sys.exit(1)\n    # ... rest of registration",
          "validation": [
            "Run python register.py",
            "Should print LLDB version before proceeding",
            "Should exit(1) if LLDB import fails"
          ]
        },
        {
          "id": "R2-T2",
          "file": "register.py",
          "description": "Write kernel.json with interrupt_mode",
          "location": "kernelspec creation section",
          "code_snippet": "kernel_json = {\n    'argv': [sys.executable, '-m', 'swift_kernel', '-f', '{connection_file}'],\n    'display_name': 'Swift',\n    'language': 'swift',\n    'interrupt_mode': 'message',\n    'env': {\n        'PYTHONPATH': os.environ.get('PYTHONPATH', ''),\n        'SWIFT_TOOLCHAIN': swift_toolchain_path,\n        'LLDB_PYTHON_PATH': lldb_python_path\n    },\n    'metadata': {\n        'debugger': True\n    }\n}\n\nwith open(os.path.join(spec_dir, 'kernel.json'), 'w') as f:\n    json.dump(kernel_json, f, indent=2)",
          "validation": [
            "After registration, cat kernel.json",
            "Verify interrupt_mode is 'message'",
            "Verify env variables are populated"
          ]
        },
        {
          "id": "R2-T3",
          "file": "register.py",
          "description": "Add --validate-only flag for testing",
          "code_snippet": "parser.add_argument('--validate-only', action='store_true',\n                    help='Validate environment without registering')\nargs = parser.parse_args()\n\nif args.validate_only:\n    if validate_lldb_python3():\n        print(\"âœ“ Environment is ready for swift-jupyter\")\n        sys.exit(0)\n    else:\n        sys.exit(1)",
          "validation": [
            "python register.py --validate-only",
            "Should check LLDB without modifying anything"
          ]
        }
      ],
      "validation_checkpoint": {
        "must_pass": [
          "python register.py --validate-only exits 0",
          "python register.py completes successfully",
          "kernel.json exists in kernelspec directory",
          "kernel.json contains interrupt_mode: message",
          "jupyter kernelspec list shows 'swift' kernel"
        ],
        "verification_commands": [
          "python register.py --validate-only",
          "python register.py --user",
          "jupyter kernelspec list | grep swift",
          "cat $(jupyter kernelspec list | grep swift | awk '{print $2}')/kernel.json | grep interrupt_mode"
        ]
      }
    },
    "R3_kernel_protocol": {
      "region_id": "R3",
      "critical_notice": "This region modifies core kernel behavior. Test thoroughly after each task. Keep swift_kernel.py.backup.",
      "backup_command": "cp swift_kernel.py swift_kernel.py.backup",
      "tasks": [
        {
          "id": "R3-T1",
          "file": "swift_kernel.py",
          "description": "Update kernel_info_reply for protocol 5.4",
          "location": "do_kernel_info or kernel_info method",
          "current_issues": [
            "May have outdated protocol_version",
            "Missing supported_features",
            "Language_info may be incomplete"
          ],
          "code_snippet": "def do_kernel_info(self):\n    return {\n        'protocol_version': '5.4',\n        'implementation': 'swift-jupyter',\n        'implementation_version': '0.4.0',\n        'language_info': {\n            'name': 'swift',\n            'version': self._get_swift_version(),\n            'mimetype': 'text/x-swift',\n            'file_extension': '.swift',\n            'pygments_lexer': 'swift',\n            'codemirror_mode': 'swift'\n        },\n        'banner': f'Swift {self._get_swift_version()} Jupyter Kernel',\n        'help_links': [\n            {\n                'text': 'Swift Documentation',\n                'url': 'https://docs.swift.org'\n            }\n        ],\n        'status': 'ok'\n    }\n\ndef _get_swift_version(self):\n    \"\"\"Extract Swift version from toolchain.\"\"\"\n    try:\n        result = subprocess.run(['swift', '--version'], \n                                capture_output=True, text=True)\n        # Parse version from output\n        return '5.9'  # or parsed version\n    except:\n        return '5.x'",
          "validation": [
            "Start kernel via jupyter console --kernel=swift",
            "In Python test: client.kernel_info()",
            "Verify protocol_version == '5.4'",
            "Verify all language_info fields present"
          ]
        },
        {
          "id": "R3-T2",
          "file": "swift_kernel.py",
          "description": "Add control channel interrupt_request handler",
          "location": "Add new method to kernel class",
          "dependencies": [
            "R3-T1"
          ],
          "code_snippet": "def interrupt_request(self, stream, ident, parent):\n    \"\"\"Handle interrupt_request on control channel (protocol 5.4).\n    \n    This is called when user clicks interrupt in Jupyter UI.\n    Should interrupt current execution and return interrupt_reply.\n    \"\"\"\n    self.log.info('Received interrupt_request on control channel')\n    \n    try:\n        # Signal the LLDB/Swift execution to stop\n        self._interrupt_execution()\n        \n        content = {'status': 'ok'}\n    except Exception as e:\n        self.log.error(f'Interrupt failed: {e}')\n        content = {'status': 'error', 'ename': str(type(e).__name__), 'evalue': str(e)}\n    \n    # Send interrupt_reply on control channel\n    self.session.send(stream, 'interrupt_reply', content, parent, ident)\n\ndef _interrupt_execution(self):\n    \"\"\"Interrupt current LLDB execution.\n    \n    This should set a flag that the execution loop checks,\n    or send a signal to the LLDB process.\n    \"\"\"\n    if hasattr(self, '_swift_shell'):\n        self._swift_shell.interrupt()\n    # Additional interrupt logic here",
          "integration_notes": [
            "May need to add interrupt() method to swift_shell",
            "Consider using threading.Event for interrupt flag",
            "LLDB may need signal handling setup"
          ],
          "validation": [
            "Start kernel and run long loop: while true { sleep(1) }",
            "Click interrupt in Jupyter UI",
            "Expect interrupt_reply within 2 seconds",
            "Expect execution to stop and cell to show interrupted status"
          ]
        },
        {
          "id": "R3-T3",
          "file": "swift_kernel.py",
          "description": "Ensure shutdown_request works on control channel",
          "location": "do_shutdown method",
          "current_issues": [
            "May only handle shell channel shutdown",
            "Need to ensure control channel compatibility"
          ],
          "code_snippet": "def do_shutdown(self, restart):\n    \"\"\"Handle shutdown from shell or control channel.\n    \n    Args:\n        restart: bool, whether this is a restart (vs full shutdown)\n    \n    Returns:\n        dict with 'status' and 'restart' keys\n    \"\"\"\n    self.log.info(f'Shutting down kernel (restart={restart})')\n    \n    try:\n        # Clean up LLDB session\n        if hasattr(self, '_swift_shell'):\n            self._swift_shell.cleanup()\n        \n        # Clean up any other resources\n        return {'status': 'ok', 'restart': restart}\n    except Exception as e:\n        self.log.error(f'Shutdown error: {e}')\n        return {'status': 'error', 'restart': restart}",
          "validation": [
            "Send shutdown_request on control channel",
            "Expect shutdown_reply within 3 seconds",
            "Kernel process should exit cleanly"
          ]
        },
        {
          "id": "R3-T4",
          "file": "swift_kernel.py",
          "description": "Update completion to handle Unicode cursor positions",
          "location": "do_complete method",
          "current_issues": [
            "Cursor_pos may be byte offset not Unicode codepoint offset",
            "Protocol 5.2+ requires Unicode positions"
          ],
          "code_snippet": "def do_complete(self, code, cursor_pos):\n    \"\"\"Handle code completion request.\n    \n    Args:\n        code: str, the entire cell content\n        cursor_pos: int, cursor position in Unicode codepoints\n    \"\"\"\n    # Ensure cursor_pos is treated as Unicode codepoint position\n    # NOT byte position\n    if cursor_pos > len(code):\n        cursor_pos = len(code)\n    \n    # Get the text before cursor for context\n    text_before_cursor = code[:cursor_pos]\n    \n    # Use LLDB/SourceKit completion\n    matches = self._get_completions(text_before_cursor)\n    \n    # Find common prefix for cursor_start/cursor_end\n    cursor_start = cursor_pos\n    cursor_end = cursor_pos\n    # Adjust based on partial identifier\n    \n    return {\n        'status': 'ok',\n        'matches': matches,\n        'cursor_start': cursor_start,\n        'cursor_end': cursor_end,\n        'metadata': {}\n    }",
          "test_cases": [
            "Code with emoji: 'ðŸ’¡let x = 5; x.'",
            "Code with Chinese: 'let å˜é‡ = 10; å˜é‡.'",
            "Ensure completions work with Unicode identifiers"
          ],
          "validation": [
            "Test completion with Unicode: 'ðŸ’¡let x = 1\\nx.' (cursor after '.')",
            "Verify cursor_start/cursor_end are correct Unicode offsets",
            "Matches should appear in UI"
          ]
        },
        {
          "id": "R3-T5",
          "file": "swift_kernel.py",
          "description": "Verify all IOPub messages use session.send",
          "location": "Throughout file - stream, display_data, execute_result",
          "audit_points": [
            "stream (stdout/stderr) messages",
            "display_data messages",
            "execute_result messages",
            "error messages",
            "update_display_data messages"
          ],
          "pattern": "# Replace manual ZMQ send with:\nself.session.send(\n    self.iopub_socket,\n    msg_type,\n    content,\n    parent=parent_header,\n    metadata=metadata\n)",
          "validation": [
            "Execute cell with print()",
            "Monitor Jupyter messages (jupyter console --debug)",
            "Verify message signatures are valid (HMAC)",
            "Verify all required header fields present"
          ]
        }
      ],
      "validation_checkpoint": {
        "must_pass": [
          "Kernel starts and returns kernel_info with protocol_version 5.4",
          "Simple execution works: print('hello')",
          "Long-running cell can be interrupted",
          "Kernel can be shut down cleanly",
          "Unicode in code and completions works"
        ],
        "test_script": "test/validate_r3.py",
        "test_script_content": "#!/usr/bin/env python3\nimport jupyter_client\nimport time\n\nkm, kc = jupyter_client.manager.start_new_kernel(kernel_name='swift')\n\ntry:\n    # Test 1: kernel_info\n    kc.kernel_info()\n    msg = kc.get_shell_msg(timeout=5)\n    assert msg['content']['protocol_version'].startswith('5.4'), 'Wrong protocol version'\n    print('âœ“ Protocol version 5.4')\n    \n    # Test 2: Simple execution\n    kc.execute('print(\"hello\")')\n    while True:\n        msg = kc.get_iopub_msg(timeout=5)\n        if msg['msg_type'] == 'execute_result' or msg['msg_type'] == 'stream':\n            print('âœ“ Simple execution works')\n            break\n    \n    # Test 3: Interrupt\n    msg_id = kc.execute('while true { Thread.sleep(forTimeInterval: 0.1) }')\n    time.sleep(1)\n    kc.interrupt()\n    # Wait for interrupt reply\n    time.sleep(2)\n    print('âœ“ Interrupt sent (check manually if it worked)')\n    \n    print('\\nâœ“ All R3 checkpoint tests passed')\nfinally:\n    km.shutdown_kernel()\n"
      },
      "rollback_procedure": [
        "cp swift_kernel.py.backup swift_kernel.py",
        "Restart jupyter",
        "Test with backup version"
      ]
    },
    "R4_display_layer": {
      "region_id": "R4",
      "approach": "Refactor Swift display code to delegate message construction to Python Session, avoiding manual HMAC/header assembly",
      "tasks": [
        {
          "id": "R4-T1",
          "file": "swift_kernel.py",
          "description": "Add Python helper methods for Swift to call",
          "location": "Add to kernel class",
          "code_snippet": "def publish_display_data(self, data, metadata=None, transient=None):\n    \"\"\"Publish display_data from Swift.\n    \n    Args:\n        data: dict of mimetype -> content\n        metadata: dict of mimetype -> metadata (optional)\n        transient: dict with display_id for updates (optional)\n    \"\"\"\n    if metadata is None:\n        metadata = {}\n    if transient is None:\n        transient = {}\n    \n    content = {\n        'data': data,\n        'metadata': metadata,\n        'transient': transient\n    }\n    \n    self.session.send(\n        self.iopub_socket,\n        'display_data',\n        content,\n        parent=self._parent_header\n    )\n\ndef publish_update_display_data(self, data, metadata=None, transient=None):\n    \"\"\"Publish update_display_data from Swift.\"\"\"\n    if metadata is None:\n        metadata = {}\n    if transient is None:\n        transient = {}\n    \n    # Transient MUST contain display_id for updates\n    assert 'display_id' in transient, 'update_display_data requires display_id'\n    \n    content = {\n        'data': data,\n        'metadata': metadata,\n        'transient': transient\n    }\n    \n    self.session.send(\n        self.iopub_socket,\n        'update_display_data',\n        content,\n        parent=self._parent_header\n    )",
          "validation": [
            "Call from Python: kernel.publish_display_data({'text/plain': 'test'})",
            "Verify message appears on iopub",
            "Verify HMAC signature is valid"
          ]
        },
        {
          "id": "R4-T2",
          "file": "KernelCommunicator.swift",
          "description": "Replace ZMQ direct send with Python bridge calls",
          "approach": "Instead of constructing Jupyter messages in Swift, pass payload to Python and let Session handle it",
          "before_pattern": "// Old: Swift builds full message with header/HMAC\nlet message = JupyterMessage(header: ..., content: ...)\nsocket.send(message.serialize())",
          "after_pattern": "// New: Swift calls Python helper\nPythonContext.shared.call(\"publish_display_data\", args: [\n    \"data\": [\"text/plain\": text],\n    \"metadata\": [:],\n    \"transient\": displayId.map { [\"display_id\": $0] } ?? [:]\n])",
          "benefits": [
            "No manual HMAC calculation in Swift",
            "Session handles all protocol details",
            "Easier to maintain protocol compliance"
          ],
          "migration_steps": [
            "Audit all sendMessage() calls in KernelCommunicator",
            "Replace with Python bridge calls",
            "Remove HMAC/signing code from Swift",
            "Keep Swift-side code focused on data preparation"
          ]
        },
        {
          "id": "R4-T3",
          "file": "EnableJupyterDisplay.swift",
          "description": "Update display() functions to use new bridge",
          "locations": [
            "display(_ object:) functions",
            "displayWithID functions",
            "MIME type helpers"
          ],
          "code_pattern": "public func display<T>(_ object: T, mimeType: String = \"text/plain\") {\n    let data = convertToMIME(object, type: mimeType)\n    let payload: [String: Any] = [\n        \"data\": [mimeType: data],\n        \"metadata\": [:]\n    ]\n    KernelCommunicator.shared.publishDisplay(payload)\n}\n\npublic func display<T>(_ object: T, id: String, mimeType: String = \"text/plain\") {\n    let data = convertToMIME(object, type: mimeType)\n    let payload: [String: Any] = [\n        \"data\": [mimeType: data],\n        \"metadata\": [:],\n        \"transient\": [\"display_id\": id]\n    ]\n    KernelCommunicator.shared.publishDisplay(payload)\n}\n\npublic func updateDisplay<T>(_ object: T, id: String, mimeType: String = \"text/plain\") {\n    let data = convertToMIME(object, type: mimeType)\n    let payload: [String: Any] = [\n        \"data\": [mimeType: data],\n        \"metadata\": [:],\n        \"transient\": [\"display_id\": id]\n    ]\n    KernelCommunicator.shared.publishUpdateDisplay(payload)\n}",
          "validation": [
            "In Swift cell: display('test')",
            "In Swift cell: let id = 'myid'; display('v1', id: id); updateDisplay('v2', id: id)",
            "Verify first shows 'v1', then updates to 'v2' in same output area"
          ]
        },
        {
          "id": "R4-T4",
          "file": "EnableIPythonDisplay.swift",
          "description": "Verify IPython 8.x compatibility",
          "checks": [
            "IPython.display imports still work",
            "matplotlib inline backend works",
            "pandas DataFrame display works"
          ],
          "test_code": "// Test in Swift cell:\nimport Python\nlet display = Python.import(\"IPython.display\")\n\n// Test 1: Simple display\ndisplay.display(display.HTML(\"<b>test</b>\"))\n\n// Test 2: Matplotlib\nlet plt = Python.import(\"matplotlib.pyplot\")\nplt.plot([1, 2, 3], [1, 4, 9])\nplt.show()\n\n// Test 3: Pandas\nlet pd = Python.import(\"pandas\")\nlet df = pd.DataFrame([\"a\": [1, 2], \"b\": [3, 4]])\ndisplay.display(df)",
          "validation": [
            "Run test code in notebook",
            "Verify HTML renders",
            "Verify plot appears as image",
            "Verify DataFrame renders as table"
          ]
        }
      ],
      "validation_checkpoint": {
        "must_pass": [
          "Swift display() emits properly signed display_data",
          "Display with ID works and can be updated",
          "IPython.display interop works",
          "No manual ZMQ/HMAC code in Swift"
        ],
        "test_notebook": "test/test_display.ipynb",
        "test_notebook_cells": [
          "display('Simple text')",
          "let id = 'test'; display('Initial', id: id); sleep(1); updateDisplay('Updated', id: id)",
          "import Python; let plt = Python.import('matplotlib.pyplot'); plt.plot([1,2,3]); plt.show()"
        ]
      }
    },
    "R5_lldb_shell": {
      "region_id": "R5",
      "approach": "Can be done in parallel with R4, focuses on execution engine",
      "tasks": [
        {
          "id": "R5-T1",
          "file": "swift_shell/execution.py (or equivalent)",
          "description": "Improve Unicode handling in code submission",
          "issues": [
            "LLDB may not handle UTF-8 properly",
            "Encoding errors when submitting code"
          ],
          "solution": "def execute_code(self, code: str) -> ExecutionResult:\n    # Ensure code is properly encoded for LLDB\n    code_bytes = code.encode('utf-8')\n    \n    # Send to LLDB with explicit encoding\n    result = self.debugger.HandleCommand(\n        f'expression -l swift -- {code}',\n        return_object=True\n    )\n    \n    # Decode output properly\n    output = result.GetOutput().decode('utf-8', errors='replace')\n    error = result.GetError().decode('utf-8', errors='replace')\n    \n    return ExecutionResult(output, error, result.Succeeded())",
          "validation": [
            "Execute: let emoji = \"ðŸ˜€\"",
            "Execute: let chinese = \"ä½ å¥½ä¸–ç•Œ\"",
            "Execute: print(emoji + chinese)",
            "Verify no encoding errors"
          ]
        },
        {
          "id": "R5-T2",
          "file": "swift_shell/execution.py",
          "description": "Add interrupt support for LLDB",
          "approach": "Hook into LLDB's interrupt mechanism or use process signals",
          "code_snippet": "class LLDBShell:\n    def __init__(self):\n        self.debugger = lldb.SBDebugger.Create()\n        self.interrupted = False\n        \n    def interrupt(self):\n        \"\"\"Interrupt current execution.\"\"\"\n        self.interrupted = True\n        \n        # Option 1: Use LLDB's interrupt\n        if self.process:\n            self.process.Stop()\n        \n        # Option 2: Set a flag that evaluation loop checks\n        # This may require modifying how we call into LLDB\n        \n    def execute_code(self, code: str) -> ExecutionResult:\n        self.interrupted = False\n        \n        # Before starting long evaluation, set up check\n        # This is tricky with LLDB - may need to run in thread\n        \n        result = self._evaluate_with_interrupt_check(code)\n        return result",
          "challenges": [
            "LLDB evaluation may not be easily interruptible",
            "May need to run LLDB in separate thread",
            "Consider timeout mechanism as fallback"
          ],
          "validation": [
            "Run infinite loop in Swift",
            "Call shell.interrupt()",
            "Expect execution to stop within 2 seconds"
          ]
        },
        {
          "id": "R5-T3",
          "file": "swift_shell/",
          "description": "Improve error messages and stack traces",
          "improvements": [
            "Parse LLDB errors into structured format",
            "Extract Swift error type and message",
            "Format stack traces nicely"
          ],
          "example_output": "SwiftError: division by zero\nLocation: MyFile.swift:42\nStack trace:\n  at functionName (MyFile.swift:42)\n  at main (MyFile.swift:10)"
        }
      ],
      "validation_checkpoint": {
        "must_pass": [
          "Unicode code executes without errors",
          "Interrupt stops long-running code",
          "Error messages are readable"
        ],
        "nice_to_have": [
          "Fast completion response time",
          "Stack traces are well formatted"
        ]
      }
    },
    "R6_testing": {
      "region_id": "R6",
      "approach": "Build comprehensive test suite to validate all previous regions",
      "structure": {
        "test/unit/": "Unit tests for individual functions",
        "test/integration/": "Protocol conformance and kernel tests",
        "test/notebooks/": "End-to-end notebook tests",
        "test/conftest.py": "Pytest fixtures and helpers"
      },
      "tasks": [
        {
          "id": "R6-T1",
          "description": "Set up pytest infrastructure",
          "files": [
            "test/conftest.py",
            "test/pytest.ini"
          ],
          "conftest_content": "import pytest\nimport jupyter_client\nimport os\n\n@pytest.fixture(scope='session')\ndef kernel_manager():\n    \"\"\"Start Swift kernel for testing.\"\"\"\n    km, kc = jupyter_client.manager.start_new_kernel(kernel_name='swift')\n    yield km, kc\n    km.shutdown_kernel()\n\n@pytest.fixture\ndef kernel_client(kernel_manager):\n    \"\"\"Get kernel client.\"\"\"\n    _, kc = kernel_manager\n    return kc",
          "pytest_ini": "[pytest]\ntestpaths = test\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\naddopts = -v --tb=short --timeout=30"
        },
        {
          "id": "R6-T2",
          "description": "Protocol conformance tests",
          "file": "test/integration/test_protocol.py",
          "tests": [
            "test_kernel_info_protocol_version",
            "test_interrupt_request",
            "test_shutdown_request",
            "test_execute_request",
            "test_complete_request",
            "test_inspect_request"
          ],
          "example": "def test_kernel_info_protocol_version(kernel_client):\n    kc = kernel_client\n    kc.kernel_info()\n    msg = kc.get_shell_msg(timeout=5)\n    assert msg['msg_type'] == 'kernel_info_reply'\n    assert msg['content']['protocol_version'].startswith('5.4')\n    assert msg['content']['language_info']['name'] == 'swift'\n\ndef test_interrupt_request(kernel_client):\n    kc = kernel_client\n    # Start long-running code\n    msg_id = kc.execute('while true { Thread.sleep(forTimeInterval: 0.1) }')\n    import time\n    time.sleep(1)\n    # Interrupt it\n    kc.interrupt()\n    # Wait for interrupt reply\n    msg = kc.get_shell_msg(timeout=5)\n    # Should get error or interrupt indication\n    # (specific behavior depends on implementation)"
        },
        {
          "id": "R6-T3",
          "description": "Display functionality tests",
          "file": "test/integration/test_display.py",
          "tests": [
            "test_simple_display",
            "test_display_with_id",
            "test_update_display",
            "test_multiple_mimetypes",
            "test_ipython_display"
          ]
        },
        {
          "id": "R6-T4",
          "description": "Notebook end-to-end tests",
          "approach": "Use nbmake to execute test notebooks",
          "test_notebooks": [
            "test/notebooks/basic_execution.ipynb",
            "test/notebooks/display_outputs.ipynb",
            "test/notebooks/error_handling.ipynb",
            "test/notebooks/unicode_support.ipynb"
          ],
          "run_command": "pytest --nbmake test/notebooks/*.ipynb"
        },
        {
          "id": "R6-T5",
          "description": "Optional: jupyter_kernel_test integration",
          "file": "test/kernel_config.json",
          "content": "{\n  \"kernel_name\": \"swift\",\n  \"test_timeout\": 10,\n  \"tests\": [\n    \"test_kernel_info\",\n    \"test_execute\",\n    \"test_complete\",\n    \"test_inspect\"\n  ]\n}",
          "run_command": "python -m jupyter_kernel_test --config test/kernel_config.json"
        }
      ],
      "validation_checkpoint": {
        "must_pass": [
          "pytest test/integration/ passes all tests",
          "pytest --nbmake test/notebooks/ passes all notebooks"
        ],
        "ci_integration": {
          "github_actions": ".github/workflows/test.yml",
          "test_matrix": [
            {
              "os": "ubuntu-22.04",
              "python": "3.10"
            },
            {
              "os": "ubuntu-22.04",
              "python": "3.11"
            },
            {
              "os": "ubuntu-22.04",
              "python": "3.12"
            },
            {
              "os": "macos-13",
              "python": "3.11"
            }
          ]
        }
      }
    },
    "R7_docker": {
      "region_id": "R7",
      "can_defer": true,
      "approach": "Update containers for modern stack; separate from core kernel work",
      "tasks": [
        {
          "id": "R7-T1",
          "file": "docker/Dockerfile",
          "description": "Modernize base image and dependencies",
          "new_dockerfile": "# Use official Swift image or Ubuntu 22.04\nFROM swift:5.9-jammy\n\n# Install Python 3.11 and Jupyter\nRUN apt-get update && apt-get install -y \\\n    python3.11 \\\n    python3.11-dev \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set Python 3.11 as default\nRUN update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.11 1\n\n# Install Jupyter stack\nWORKDIR /swift-jupyter\nCOPY requirements.txt .\nRUN pip3 install --no-cache-dir -r requirements.txt\n\n# Copy kernel code\nCOPY . .\n\n# Register kernel\nRUN python3 register.py --user\n\n# Expose Jupyter port\nEXPOSE 8888\n\n# Add healthcheck\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD jupyter --version || exit 1\n\n# Start Jupyter\nCMD [\"jupyter\", \"notebook\", \"--ip=0.0.0.0\", \"--allow-root\", \"--no-browser\"]",
          "validation": [
            "docker build -t swift-jupyter:test .",
            "docker run -p 8888:8888 swift-jupyter:test",
            "Access http://localhost:8888 and run test notebook"
          ]
        },
        {
          "id": "R7-T2",
          "file": "kernel_gateway/Dockerfile",
          "description": "Update for Jupyter Server 2.x",
          "notes": [
            "Kernel Gateway may need updates for Jupyter Server 2.x",
            "Consider using jupyter-server-proxy if needed",
            "Add health check endpoint"
          ]
        }
      ],
      "validation_checkpoint": {
        "must_pass": [
          "Docker image builds successfully",
          "Can run container and access Jupyter",
          "Kernel works inside container"
        ],
        "nice_to_have": [
          "Image size is reasonable (<2GB)",
          "Healthcheck works",
          "Multi-stage build for smaller size"
        ]
      }
    }
  },
  "execution_strategy": {
    "recommended_order": [
      "Preflight checks",
      "R1 (Foundation) - Low risk, establishes baseline",
      "R2 (Registration) - Low risk, quick win",
      "R3 (Core Protocol) - HIGH PRIORITY, most critical",
      "R4 + R5 in parallel (Display + LLDB) - Can be done simultaneously",
      "R6 (Testing) - Validates everything",
      "R7 (Docker) - Optional, can defer"
    ],
    "decision_points": [
      {
        "after": "R3",
        "decision": "Core kernel works? If yes, continue. If no, debug before proceeding.",
        "fallback": "Rollback R3, review logs, adjust approach"
      },
      {
        "after": "R4 + R5",
        "decision": "Display and execution robust? If yes, proceed to testing.",
        "fallback": "Iterate on problematic region"
      }
    ],
    "session_management": {
      "session_1": {
        "regions": [
          "R1",
          "R2"
        ],
        "duration": "2-3 hours",
        "goal": "Foundation and registration complete",
        "deliverable": "Can register modern kernel"
      },
      "session_2": {
        "regions": [
          "R3"
        ],
        "duration": "4-6 hours",
        "goal": "Protocol 5.4 compliance",
        "deliverable": "Kernel works with interrupt and shutdown",
        "critical": true
      },
      "session_3": {
        "regions": [
          "R4"
        ],
        "duration": "3-4 hours",
        "goal": "Modern display layer",
        "deliverable": "Display via Session, no manual HMAC"
      },
      "session_4": {
        "regions": [
          "R5"
        ],
        "duration": "3-4 hours",
        "goal": "LLDB robustness",
        "deliverable": "Unicode and interrupt work well"
      },
      "session_5": {
        "regions": [
          "R6"
        ],
        "duration": "2-3 hours",
        "goal": "Comprehensive testing",
        "deliverable": "Test suite passes"
      },
      "session_6": {
        "regions": [
          "R7"
        ],
        "duration": "2-3 hours",
        "goal": "Docker updates",
        "deliverable": "Working container image",
        "optional": true
      }
    }
  },
  "success_metrics": {
    "critical_must_have": [
      "Kernel starts and connects to JupyterLab 4",
      "Protocol version 5.4 reported",
      "Simple Swift execution works: print(), variables, functions",
      "Interrupt functionality works reliably",
      "Can shut down kernel cleanly",
      "Display outputs appear in notebook"
    ],
    "important": [
      "Unicode in code and identifiers works",
      "Code completion works",
      "Error messages are readable",
      "Can handle moderate output volumes",
      "Test suite passes on Ubuntu 22.04 + Python 3.11"
    ],
    "nice_to_have": [
      "Works on macOS",
      "Docker images work",
      "Performance is good (sub-second for simple exec)",
      "Advanced display (matplotlib, HTML) works",
      "Code inspection/help works"
    ]
  },
  "risk_management": {
    "high_risks": [
      {
        "risk": "LLDB Python 3 bindings incompatible or missing",
        "impact": "Kernel won't start",
        "probability": "medium",
        "mitigation": [
          "Preflight validation catches this early",
          "Document required Swift toolchain versions",
          "Provide troubleshooting guide"
        ],
        "contingency": "May need to use Swift REPL instead of LLDB (major rework)"
      },
      {
        "risk": "Interrupt mechanism doesn't work with LLDB",
        "impact": "Can't stop long-running cells",
        "probability": "medium",
        "mitigation": [
          "Test early in R3",
          "Consider timeout-based fallback",
          "Research LLDB interrupt capabilities"
        ],
        "contingency": "Document limitation; suggest restart kernel"
      },
      {
        "risk": "Swift-Python bridge breaks with display refactor",
        "impact": "No output in notebooks",
        "probability": "low",
        "mitigation": [
          "Test incrementally during R4",
          "Keep old code path as fallback initially",
          "Thorough testing before removing old code"
        ],
        "contingency": "Rollback R4, use old display mechanism"
      }
    ],
    "medium_risks": [
      {
        "risk": "Unicode handling edge cases",
        "impact": "Some code fails to execute",
        "probability": "medium",
        "mitigation": [
          "Test with diverse Unicode early",
          "Use Python's built-in Unicode handling"
        ]
      },
      {
        "risk": "ipykernel API changes from 6.x",
        "impact": "Kernel class needs adjustments",
        "probability": "low",
        "mitigation": [
          "Review ipykernel changelog",
          "Test with both 6.29 and 7.x if available"
        ]
      }
    ]
  },
  "rollback_strategy": {
    "global": {
      "git_workflow": "Work on modernization-branch; tag after each successful region",
      "tags": [
        "v0.4.0-baseline (before changes)",
        "v0.4.0-r1-complete",
        "v0.4.0-r2-complete",
        "v0.4.0-r3-complete",
        "etc."
      ]
    },
    "per_region_rollback": {
      "R1": "Simple git revert; no runtime impact",
      "R2": "jupyter kernelspec uninstall swift; git revert; re-register",
      "R3": "cp swift_kernel.py.backup swift_kernel.py; restart kernel",
      "R4": "Git revert Swift files; existing functionality preserved",
      "R5": "Git revert; LLDB changes are isolated",
      "R6": "Tests are additive; no rollback needed",
      "R7": "Docker is separate; rebuild old image"
    },
    "emergency_recovery": {
      "symptom": "Kernel won't start at all",
      "steps": [
        "jupyter kernelspec uninstall swift",
        "git checkout v0.4.0-baseline",
        "Re-register: python register.py",
        "Test: jupyter console --kernel=swift"
      ]
    }
  },
  "claude_code_instructions": {
    "before_starting": [
      "Run all preflight checks",
      "Create baseline snapshot",
      "Create git branch: git checkout -b swift-jupyter-modernization",
      "Backup critical files: cp swift_kernel.py swift_kernel.py.backup"
    ],
    "during_execution": [
      "Focus on ONE region per session",
      "Complete all tasks in a region before moving to next",
      "Run validation checkpoint after each region",
      "Git commit after each completed region with message: 'Region RX complete: [summary]'",
      "Tag successful regions: git tag v0.4.0-rX-complete"
    ],
    "between_regions": [
      "Review validation results",
      "Document any issues or deviations",
      "Update this plan if approach needs adjustment",
      "Take break if needed (long project)"
    ],
    "testing_approach": [
      "After R3: Manual testing crucial - start kernel, run cells, interrupt, shutdown",
      "After R4: Test display outputs thoroughly",
      "After R5: Test Unicode and edge cases",
      "After R6: Full test suite must pass"
    ],
    "when_stuck": [
      "Review relevant Jupyter docs (links in meta.references)",
      "Check LLDB Python API docs",
      "Review git history for context",
      "Consider asking for help with specific error messages"
    ],
    "completion_criteria": [
      "All critical success metrics achieved",
      "Test suite passes",
      "Documentation updated",
      "Changes committed and tagged"
    ]
  },
  "documentation_updates": {
    "README.md": {
      "sections_to_add": [
        "Modernization Status (2025)",
        "Tested Environments",
        "Troubleshooting",
        "Known Limitations"
      ]
    },
    "CHANGELOG.md": {
      "create": true,
      "entry": "## [0.4.0] - 2025-10-17\n### Changed\n- Updated to Jupyter Protocol 5.4\n- Python 3.10-3.12 support\n- Modern Jupyter stack (jupyter-client 8.x, JupyterLab 4.x)\n- Message-based interrupt support\n- Improved Unicode handling\n\n### Fixed\n- LLDB Python 3 compatibility\n- Display output signing via Session\n- Kernel shutdown on control channel"
    }
  }
}